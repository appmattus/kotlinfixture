= Configuration options
:toc:

The default configuration can be overridden when creating the fixture object or
when creating a particular implementation.

It is possible to create a new fixture based on an existing one, which allows
the addition of configuration changes:

[source,kotlin]
----
val baseFixture = kotlinFixture {
    factory<Int> { 3 }
}

val fixture = baseFixture.new {
    factory<Long> { 100L }
}

println(fixture<Long>()) // <1>
println(fixture<Int>()) // <2>
----
<1> Prints 100
<2> Prints 3

== repeatCount

Used to determine the length used for lists and maps.

[source,kotlin]
----
val fixture = kotlinFixture {
    repeatCount { 3 }
}

val listOfThreeItems = fixture<List<String>>()

val listOfSevenItems = fixture<List<String>> {
    // Overrides the parent configuration
    repeatCount { 7 }
}

----

`repeatCount` is a factory method so can be used to return lists and maps of
different lengths each execution:

[source,kotlin]
----
repeatCount {
    random.nextInt(1, 5)
}
----

== subType

Used to always return an instance of a particular subclass for a superclass.

[source,kotlin]
----
val fixture = kotlinFixture {
    subType<Number, Int>()
}

val alwaysInt = fixture<Number>()

val alwaysFloat = fixture<Number> {
    // Overrides the parent configuration
    subType<Number, Float>()
}
----

== factory

Used to return the given instance for a particular class using a factory
method.

[source,kotlin]
----
val fixture = kotlinFixture {
    factory<Number> {
        41
    }
}

val alwaysFortyOne = fixture<Number>()

val alwaysOnePointFive = fixture<Number> {
    // Overrides the parent configuration
    factory<Number> {
        1.5
    }
}
----

As `factory` is a factory method you can return different values on every
execution:

[source,kotlin]
----
factory<Number> {
    random.nextInt(10, 50)
}
----

=== Date and Calendar instances

By default `Date` and `Calendar` instances pick a date within 10 years of
1 Jan 2020.

This can be overridden using `factory` which has some built in constructs:

[source,kotlin]
----
val fixture = kotlinFixture {
    // Generate using ranges (and iterables)
    factory<Int> { range(1..10) }

    // Generate between two dates
    factory<Date> { between(startDate, endDate) }
}

val betweenTwoDates = fixture<Date>()

// You can also override at instance creation

val pastDate = fixture<Date> {
    factory<Date> { before(Date()) }
}

val futureDate = fixture<Date> {
    factory<Date> { after(Date()) }
}
----

== filter

Used to allow generated values to be filtered using standard sequence
functions.

[source,kotlin]
----
val fixture = kotlinFixture {
    filter<Int> {
        filter { it % 2 == 0 }
    }

    // Can be used to return distinct values.
    // NOTE: As the sequence is infinite, distinct will hang if no more
    // distinct values can be generated
    filter<String> {
        distinct()
    }
}

val evenNumber = fixture<Int>()

val evenNumberLessThan100 = fixture<Int> {
    // Overrides the parent configuration
    filter<Int> {
        filter { it < 100 }
    }
}
----

== property

Used to override constructor parameters or mutable properties when generating
instances of generic classes.

Given the following Kotlin class:

[source,kotlin]
----
class KotlinClass(val readOnly: String, private var private: String) {
    var member: String? = null
}
----

We can override creating an instance of `KotlinClass` as follows:

[source,kotlin]
----
val fixture = kotlinFixture {
    // Public constructor parameters overridden by reference:
    property(KotlinClass::readOnly) { "a" }

    // Private constructor parameters are overridden by name:
    property<KotlinClass, String>("private") { "b" }

    // Public member properties overridden by reference:
    property(KotlinClass::member) { "c" }
}
----

Given the following Java class:

[source,java]
----
public class JavaClass {
    private final String constructor;
    private String mutable;

    public JavaClass(String constructor) { this.constructor = constructor; }

    public void setMutable(String mutable) { this.mutable = mutable; }
}
----

We can override creating an instance of `JavaClass` as follows:

[source,kotlin]
----
val fixture = kotlinFixture {
    // Setter overridden by reference:
    property<String>(JavaClass::setMutable) { "d" }

    // Constructor parameters don't typically retain names and so are
    // overridden by a positional 'arg' names:
    property<JavaClass, String>("arg0") { "e" }
}
----

== random

By default a `Random` class is used that will generate unique values between
runs. If you want repeatability you can specify a seeded `Random` instance.

[source,kotlin]
----
val fixture = kotlinFixture {
    random = Random(seed = 10)
}

val alwaysTheSame = fixture<Int>()

// Can be specified on creation, but makes the result static
val aStaticValue = fixture<Int> {
    random = Random(seed = 5)
}
----

== nullabilityStrategy

By default when the library comes across a nullable type, such as `String?` it
will randomly return a value or null. This can be overridden by setting a
nullability strategy.

[source,kotlin]
----
val fixture = kotlinFixture {
    // All nullable types will be populated with a value
    nullabilityStrategy(NeverNullStrategy)
}

// You can also override at instance creation

fixture<AnObject> {
    // All nullable types will be populated with null
    nullabilityStrategy(AlwaysNullStrategy)
}
----

It is also possible to define and implement your own nullability strategy by
implementing `NullabilityStrategy` and applying it as above.

== optionalStrategy

By default when the library comes across an optional type, such as
`value: String = &quot;default&quot;` it will randomly return that default value
or a generated value. This can be overridden by setting an optional
strategy.

[source,kotlin]
----
val fixture = kotlinFixture {
    // All optionals will be populated with generated values
    optionalStrategy(NeverOptionalStrategy)
}

// You can also override at instance creation

fixture<AnObject> {
    // All optionals will be populated with their default value
    optionalStrategy(AlwaysOptionalStrategy) {
        // You can override the strategy for a particular class
        classOverride<AnotherObject>(NeverOptionalStrategy)

        // You can override the strategy for a property of a class
        propertyOverride(AnotherObject::property, RandomlyOptionalStrategy)
    }
}
----

== recursionStrategy

When recursion is detected the library will, by default, throw an
`UnsupportedOperationException` with the details of the circular reference. This
strategy can be changed to instead return `null` for the reference, however, if
this results in an invalid object an exception will still be thrown as the
object requested couldn't be resolved.

[source,kotlin]
----
val fixture = kotlinFixture {
    recursionStrategy(NullRecursionStrategy)
}

// You can also override at instance creation

fixture<AnObject> {
    recursionStrategy(NullRecursionStrategy)
}
----

It is also possible to define and implement your own recursion strategy by
implementing `RecursionStrategy` and applying it as above.

== loggingStrategy

A basic logger can be applied using the built in `SysOutLoggingStrategy`. It is
also possible to define and implement your own logging strategy by implementing
`LoggingStrategy` and applying it as below.

[source,kotlin]
----
val fixture = kotlinFixture {
    loggingStrategy(SysOutLoggingStrategy)
}

fixture<String> {
    // You can also override at instance creation
    loggingStrategy(SysOutLoggingStrategy)
}
----

This outputs:

[source,text]
----
ktype kotlin.String →
    class kotlin.String →
        Success(5878ec34-c30f-40c7-ad52-c15a39b44ac1)
    Success(5878ec34-c30f-40c7-ad52-c15a39b44ac1)
----
